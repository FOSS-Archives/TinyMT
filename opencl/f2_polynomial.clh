#ifndef F2_POLYNOMIAL_CLH
#define F2_POLYNOMIAL_CLH
/**
 * @file f2_polynomial.clh
 *
 * @brief calculation of polynomial over F<sub>2</sub> of degree less than 128.
 *
 * Polynomial calculation for TinyMT jump function.
 * polynomial_power_mod is used in jump32.c and jump64.c
 * In this file, polynomial of degree less than 256 is defined,
 * but the 256-bit polynomial is used only for intermediate value,
 * multiplication between 256-bit polynomials are not supported.
 *
 * @author Mutsuo Saito (Hiroshima University)
 * @author Makoto Matsumoto (The University of Tokyo)
 *
 * Copyright (C) 2011,2012 Mutsuo Saito, Makoto Matsumoto,
 * Hiroshima University and University of Tokyo.
 * All rights reserved.
 *
 * The 3-clause BSD License is applied to this software, see
 * LICENSE.txt
 */

/**
 * Polynomial over F<sub>2</sub>, whose degree is equal to or less than 128.
 * LSB of ar[0], i.e. ar[0] & 1, represent constant
 */
struct TINYMT_F2_POLYNOMIAL128_T {
    ulong ar[2];
};

typedef struct TINYMT_F2_POLYNOMIAL128_T tinymt_f2_polynomial;

inline static void
tinymt_strtopolynomial(tinymt_f2_polynomial * poly, __constant char * str);
//void polynomialtostr(char * str, const tinymt_f2_polynomial * poly);
inline static void
tinymt_polynomial_power_mod(tinymt_f2_polynomial * dest,
			    const tinymt_f2_polynomial * x,
			    ulong lower_power,
			    ulong upper_power,
			    const tinymt_f2_polynomial * mod);
inline static void
tinymt_calculate_jump_polynomial(tinymt_f2_polynomial *jump_poly,
				 ulong lower_step,
				 ulong upper_step,
				 __constant char * poly_str);
/**
 * This structure represents polynomial over F<sub>2</sub> of
 * degree less than 256.
 */
struct TINYMT_POLYNOMIAL256_T {
    ulong ar[4];
};

typedef struct TINYMT_POLYNOMIAL256_T tinymt_polynomial256;
//typedef tinymt_f2_polynomial pol;

inline static void
tinymt_shiftup_lpol1(tinymt_polynomial256 *dest);
inline static void
tinymt_shiftup_lpol_n0(tinymt_polynomial256 *dest, int n);
inline static void
tinymt_shiftup_lpol_n1(tinymt_polynomial256 *dest, int n);
inline static void
tinymt_shiftup_lpol_n2(tinymt_polynomial256 *dest, int n);
inline static void
tinymt_shiftup_lpol_n3(tinymt_polynomial256 *dest, int n);
inline static int
tinymt_deg_lpol_lazy(const tinymt_polynomial256 * x,
		     const int pre_deg);

inline static
void tinymt_mod_lpol(tinymt_polynomial256 *dest,
		     const tinymt_polynomial256 *x);
/**
 * addition of F<sub>2</sub>-polynomial<br>
 * dest = dest + src
 * @param dest destination polynomial
 * @param src source polynomial
 */
inline static void
tinymt_add_lpol(tinymt_polynomial256 * dest, const tinymt_polynomial256 * src)
{
    dest->ar[0] ^= src->ar[0];
    dest->ar[1] ^= src->ar[1];
    dest->ar[2] ^= src->ar[2];
    dest->ar[3] ^= src->ar[3];
}

/**
 * clear polynomial.
 * dest = 0
 * @param dest polynomial set to be zero.
 */
inline static void
tinymt_clear_lpol(tinymt_polynomial256 * dest)
{
    dest->ar[0] = 0;
    dest->ar[1] = 0;
    dest->ar[2] = 0;
    dest->ar[3] = 0;
}

/**
 * convert 128-bit polynomial to 256-bit polynomial
 * @param dest 256-bit polynomial
 * @param src 128-bit polynomial
 */
inline static void
tinymt_tolpol(tinymt_polynomial256 * dest,
	      const tinymt_f2_polynomial * src)
{
    dest->ar[0] = src->ar[0];
    dest->ar[1] = src->ar[1];
    dest->ar[2] = 0;
    dest->ar[3] = 0;
}

/**
 * shift up 1 bit, if indeterminate of dest is <b>t</b>
 * dest = dest * <b>t</b>
 * @param dest 256-bit polynomial
 */
inline static void
tinymt_shiftup_lpol1(tinymt_polynomial256 *dest)
{
    ulong msb0 = dest->ar[0] >> 63;
    ulong msb1 = dest->ar[1] >> 63;
    ulong msb2 = dest->ar[2] >> 63;
    dest->ar[0] = dest->ar[0] << 1;
    dest->ar[1] = (dest->ar[1] << 1) | msb0;
    dest->ar[2] = (dest->ar[2] << 1) | msb1;
    dest->ar[3] = (dest->ar[3] << 1) | msb2;
}

/**
 * shift down 1 bit, if indeterminate of dest is <b>t</b>
 * dest = dest / <b>t</b>
 * @param dest 256-bit polynomial
 */
inline static void
tinymt_shiftdown_lpol1(tinymt_polynomial256 *dest)
{
    ulong lsb0 = dest->ar[1] << 63;
    ulong lsb1 = dest->ar[2] << 63;
    ulong lsb2 = dest->ar[3] << 63;
    dest->ar[0] = (dest->ar[0] >> 1) | lsb0;
    dest->ar[1] = (dest->ar[1] >> 1) | lsb1;
    dest->ar[2] = (dest->ar[2] >> 1) | lsb2;
    dest->ar[3] = (dest->ar[3] >> 1);
}

/**
 * shift up n bit, if indeterminate of dest is <b>t</b>
 * dest = dest * <b>t</b><sup>n</sup>
 * @param dest 256-bit polynomial
 * @param n number of shift up
 */
inline static void
tinymt_shiftup_lpoln(tinymt_polynomial256 * dest, int n)
{
    if (n <= 64) {
	tinymt_shiftup_lpol_n0(dest, n);
    } else if (n <= 128) {
	tinymt_shiftup_lpol_n1(dest, n);
    } else if (n <= 192) {
	tinymt_shiftup_lpol_n2(dest, n);
    } else {
	tinymt_shiftup_lpol_n3(dest, n);
    }
}

/**
 * subcontract function: n < =64
 * shift up n bit, if indeterminate of dest is <b>t</b>
 * dest = dest * <b>t</b><sup>n</sup>
 * @param dest 256-bit polynomial
 * @param n number of shift up
 */
inline static void
tinymt_shiftup_lpol_n0(tinymt_polynomial256 *dest, int n)
{
    ulong msb0 = dest->ar[0] >> (64 - n);
    ulong msb1 = dest->ar[1] >> (64 - n);
    ulong msb2 = dest->ar[2] >> (64 - n);
    dest->ar[3] = (dest->ar[3] << n) | msb2;
    dest->ar[2] = (dest->ar[2] << n) | msb1;
    dest->ar[1] = (dest->ar[1] << n) | msb0;
    dest->ar[0] = dest->ar[0] << n;
}

/**
 * subcontract function: 64 < n <= 128
 * shift up n bit, if indeterminate of dest is <b>t</b>
 * dest = dest * <b>t</b><sup>n</sup>
 * @param dest 256-bit polynomial
 * @param n number of shift up
 */
inline static void
tinymt_shiftup_lpol_n1(tinymt_polynomial256 *dest, int n)
{
    n -= 64;
    ulong msb0 = dest->ar[0] >> (64 - n);
    ulong msb1 = dest->ar[1] >> (64 - n);
    dest->ar[3] = (dest->ar[2] << n) | msb1;
    dest->ar[2] = (dest->ar[1] << n) | msb0;
    dest->ar[1] = (dest->ar[0] << n);
    dest->ar[0] = 0;
}

/**
 * subcontract function: 128 < n <= 192
 * shift up n bit, if indeterminate of dest is <b>t</b>
 * dest = dest * <b>t</b><sup>n</sup>
 * @param dest 256-bit polynomial
 * @param n number of shift up
 */
inline static void
tinymt_shiftup_lpol_n2(tinymt_polynomial256 *dest, int n)
{
    n -= 128;
    ulong msb0 = dest->ar[0] >> (64 - n);
    dest->ar[3] = (dest->ar[1] << n) | msb0;
    dest->ar[2] = (dest->ar[0] << n);
    dest->ar[1] = 0;
    dest->ar[0] = 0;
}

/**
 * subcontract function: 192 < n <= 256
 * shift up n bit, if indeterminate of dest is <b>t</b>
 * dest = dest * <b>t</b><sup>n</sup>
 * @param dest 256-bit polynomial
 * @param n number of shift up
 */
inline static void
tinymt_shiftup_lpol_n3(tinymt_polynomial256 *dest, int n)
{
    n -= 192;
    dest->ar[3] = dest->ar[0] << n;
    dest->ar[2] = 0;
    dest->ar[1] = 0;
    dest->ar[0] = 0;
}

/**
 * get degree
 * if polynomial is zero return -1, else return degree of the polynomial.
 * @param x polynomial
 * @return degree
 */
inline static int
tinymt_deg_lpol(const tinymt_polynomial256 * x)
{
    return tinymt_deg_lpol_lazy(x, 255);
}

/**
 * sub function
 * pre_deg >= deg (must be)
 * @param x polynomial
 * @param pre_deg search start degree
 * @return degree
 */
inline static int
tinymt_deg_lpol_lazy(const tinymt_polynomial256 * x, const int pre_deg)
{
    int deg = pre_deg;
    ulong mask;
    int index = pre_deg / 64;
    int bit_pos = pre_deg % 64;

    mask = 1UL << bit_pos;
    for (int i = index; i >= 0; i--) {
	while (mask != 0) {
	    if ((x->ar[i] & mask) != 0) {
		return deg;
	    }
	    mask = mask >> 1;
	    deg--;
	}
	mask = 1UL << 63;
    }
    return -1; // should be minus infinity
}

/**
 * multiplication of polynomials
 * y's degree is assumed to be lower than 128 <br>
 * x = x * y
 * @param x polynomial
 * @param y polynomial
 */
inline static void
tinymt_mul_pol(tinymt_polynomial256 *x, const tinymt_polynomial256 *y)
{
    tinymt_polynomial256 result_z;
    tinymt_polynomial256 *result = &result_z;
    tinymt_clear_lpol(result);
    ulong y64 = y->ar[0];
    for (int i = 0; i < 64; i++) {
	if ((y64 & 1) != 0) {
	    tinymt_add_lpol(result, x);
	}
	tinymt_shiftup_lpol1(x);
	y64 = y64 >> 1;
	if ((y64 == 0) && (y->ar[1] == 0)) {
	    break;
	}
    }
    y64 = y->ar[1];
    while (y64 != 0) {
	if ((y64 & 1) != 0) {
	    tinymt_add_lpol(result, x);
	}
	tinymt_shiftup_lpol1(x);
	y64 = y64 >> 1;
    }
    *x = *result;
}

/**
 * square polynomial <br>
 * x = x * x
 * @param x polynomial
 */
inline static void
tinymt_square_lpol(tinymt_polynomial256 *x)
{
    tinymt_polynomial256 tmp;
    tmp = *x;
    tinymt_mul_pol(x, &tmp);
}

/**
 * remainder of polynomial
 * dest = dest % x
 * @param dest polynomial to be divided and remainder
 * @param x divisor
 */
inline static void
tinymt_mod_lpol(tinymt_polynomial256 *dest,
		const tinymt_polynomial256 *x)
{
    tinymt_polynomial256 tmp_z;
    tinymt_polynomial256 * tmp = &tmp_z;
    int deg = tinymt_deg_lpol(x);
    int dest_deg = tinymt_deg_lpol(dest);
    int diff = dest_deg - deg;
    int tmp_deg = deg;
    if (diff < 0) {
	return;
    }
    *tmp = *x;
    if (diff == 0) {
	tinymt_add_lpol(dest, tmp);
	return;
    }
    tinymt_shiftup_lpoln(tmp, diff);
    tmp_deg += diff;
    tinymt_add_lpol(dest, tmp);
    dest_deg = tinymt_deg_lpol_lazy(dest, dest_deg);
    while (dest_deg >= deg) {
	tinymt_shiftdown_lpol1(tmp);
	tmp_deg--;
	if (dest_deg == tmp_deg) {
	    tinymt_add_lpol(dest, tmp);
	    dest_deg = tinymt_deg_lpol_lazy(dest, dest_deg);
	}
    }
}

/**
 * conversion form 256-bit polynomial to 128-bit polynomial.
 * @param dest 128-bit polynomial
 * @param x 256-bit polynomial
 */
inline static void
tinymt_topol(tinymt_f2_polynomial * dest,
	     const tinymt_polynomial256 * x)
{
    dest->ar[0] = x->ar[0];
    dest->ar[1] = x->ar[1];
}

/**
 * conversion from string to polynomial.
 * string must be in the format of TinyMTDC outputs.
 * @param poly 128-bit polynomial
 * @param str hexadecimal string of 128-bit polynomial.
 */
inline static void
tinymt_strtopolynomial(tinymt_f2_polynomial * poly, __constant char * str)
{
    poly->ar[0] = 0;
    poly->ar[1] = 0;
    int c;
    for (int i = 0; i < 2; i++) {
	for (int j = 0; j < 16; j++) {
	    c = str[i * 16 + j];
	    if (c >= '0' && c <= '9') {
		c = c - '0';
	    } else {
		c = c - 'a' + 10;
	    }
	    poly->ar[1 - i] = poly->ar[1 - i] * 16 + c;
	}
    }
}

/**
 * dest = x<sup>power</sup> % mod
 * @param dest the result of calculation
 * @param x polynomial
 * @param lower_power lower 128 bit of power
 * @param upper_power upper 128 bit of power
 * @param mod divisor polynomial
 */
inline static void
tinymt_polynomial_power_mod(tinymt_f2_polynomial * dest,
			    const tinymt_f2_polynomial * x,
			    ulong lower_power,
			    ulong upper_power,
			    const tinymt_f2_polynomial * mod)
{
    tinymt_polynomial256 tmp_z;
    tinymt_polynomial256 * tmp = &tmp_z;
    tinymt_polynomial256 result_z;
    tinymt_polynomial256 * result = & result_z;
    tinymt_polynomial256 lmod_z;
    tinymt_polynomial256 * lmod = &lmod_z;
    tinymt_tolpol(tmp, x);
    tinymt_tolpol(lmod, mod);
    tinymt_clear_lpol(result);
    result_z.ar[0] = 1;
    for (int i = 0; i < 64; i++) {
	if ((lower_power & 1) != 0) {
	    tinymt_mul_pol(result, tmp);
	    tinymt_mod_lpol(result, lmod);
	}
	tinymt_square_lpol(tmp);
	tinymt_mod_lpol(tmp, lmod);
	lower_power = lower_power >> 1;
	if ((lower_power == 0) && (upper_power == 0)) {
	    break;
	}
    }
    while (upper_power != 0) {
	if ((upper_power & 1) != 0) {
	    tinymt_mul_pol(result, tmp);
	    tinymt_mod_lpol(result, lmod);
	}
	tinymt_square_lpol(tmp);
	tinymt_mod_lpol(tmp, lmod);
	upper_power = upper_power >> 1;
    }
    tinymt_topol(dest, result);
    return;
}

/**
 * calculate jump polynomial.
 * The jump polynomial is used in tinymt32_jump_by_polynomial
 * or tinymt64_jump_by_polynomial.
 * This function is time consuming.
 * The jump polynomial calculated by this function should be used for
 * the same tinymt, in other words, for the tinymts which have the
 * same characteristic polynomial.
 * @param jump_poly the result of this calculation.
 * @param lower_step lower bit of 128-bit integer
 * @param upper_step upper bit of 128-bit integer
 * @param poly_str string of the characteristic polynomial generated by
 * tinymt32dc
 */
inline static void
tinymt_calculate_jump_polynomial(tinymt_f2_polynomial *jump_poly,
				 ulong lower_step,
				 ulong upper_step,
				 __constant char * poly_str)
{
    tinymt_f2_polynomial charcteristic;
    tinymt_f2_polynomial tee;

    tinymt_strtopolynomial(&charcteristic, poly_str);
    tee.ar[0] = 2;
    tee.ar[1] = 0;
    tinymt_polynomial_power_mod(jump_poly,
				&tee,
				lower_step,
				upper_step,
				&charcteristic);
}
#endif
